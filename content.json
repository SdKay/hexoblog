{"meta":{"title":"云处安","subtitle":"sdking的笔记本","description":"","author":"Sdking Tsing","url":"https://note.sdking.fun","root":"/"},"pages":[{"title":"","date":"2021-11-25T14:26:22.368Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"404.html","permalink":"https://note.sdking.fun/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"about","date":"2021-06-23T14:36:16.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"about/index.html","permalink":"https://note.sdking.fun/about/index.html","excerpt":"","text":"欢迎关注我的公众号 sdking的小破站","author":"sdking"},{"title":"分类","date":"2021-06-08T13:11:20.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"categories/index.html","permalink":"https://note.sdking.fun/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-11-25T14:26:22.368Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"friends/index.html","permalink":"https://note.sdking.fun/friends/index.html","excerpt":"","text":""},{"title":"more","date":"2021-06-10T15:08:44.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"more/index.html","permalink":"https://note.sdking.fun/more/index.html","excerpt":"","text":"","author":"sdking"},{"title":"","date":"2021-11-25T14:26:22.368Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"nags/index.html","permalink":"https://note.sdking.fun/nags/index.html","excerpt":"","text":""},{"title":"notes","date":"2021-06-10T15:02:17.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"notes/index.html","permalink":"https://note.sdking.fun/notes/index.html","excerpt":"","text":"","author":"sdking"},{"title":"标签","date":"2021-06-08T13:15:24.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"tags/index.html","permalink":"https://note.sdking.fun/tags/index.html","excerpt":"","text":"","author":"sdking"}],"posts":[{"title":"音乐分享-故乡 by 许巍","slug":"life/音乐分享-故乡","date":"2021-11-25T14:26:22.368Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/life/音乐分享-故乡/","link":"","permalink":"https://note.sdking.fun/blog/life/%E9%9F%B3%E4%B9%90%E5%88%86%E4%BA%AB-%E6%95%85%E4%B9%A1/","excerpt":"","text":"Your browser does not support the audio tag. 故乡-许巍12345678910111213141516171819202122232425262728293031天边夕阳再次映上 我的脸庞再次映着我那 不安的心这是什么地方 依然是如此的荒凉那无尽的旅程 如此漫长我是永远向着远方 独行的浪子你是茫茫人海之中 我的女人在异乡的路上 每一个寒冷的夜晚这思念它如刀 让我伤痛总是在梦里 我看到你无助的双眼我的心 又一次被唤醒我站在这里 想起和你曾经离别情景你站在 人群中间 那么孤单那是你 破碎的心我的心 却那么狂野你在我的心里 永远是故乡你总为我独自守候 沉默等待在异乡的路上 每一个寒冷的夜晚这思念它如刀 让我伤痛总是在梦里 我看到你无助的双眼我的心 又一次被唤醒我站在这里 想起和你曾经离别情景你站在 人群中间 那么孤单那是你 破碎的心我的心 却那么狂野总是在梦里 我看到你无助的双眼我的心 又一次被唤醒总是在梦里 看到自己走在归乡路上你站在 夕阳下面 容颜娇艳那是你 衣裙漫飞那是你 温柔如水","categories":[{"name":"life","slug":"life","permalink":"https://note.sdking.fun/categories/life/"}],"tags":[{"name":"music","slug":"music","permalink":"https://note.sdking.fun/tags/music/"}],"author":"sdking"},{"title":"c_cpp基础-变量作用域","slug":"cpp_foundation/c_cpp基础-变量作用域","date":"2021-11-25T13:38:44.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/cpp_foundation/c_cpp基础-变量作用域/","link":"","permalink":"https://note.sdking.fun/blog/cpp_foundation/c_cpp%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"变量的作用域作为变量的一个重要的属性，在使用中有许多细节值得深入学习 作用域 变量作用域：变量在代码中可见的区域 全局作用域：在全局范围(整个program)可见的区域 局部作用域：在局部范围可见的区域 文件作用域：在文件范围内的代码可见的区域 变量作用域 全局变量：具有全局作用域的变量 局部变量：具有局部作用域的变量 初始化 全局变量：未初始化的全局变量编译器会为其设置默认值0(为什么？参考推荐阅读或阅读原文) 局部变量：未初始化时其值是未定义的 推荐阅读 目标文件组成(1)","categories":[{"name":"c/cpp基础","slug":"c-cpp基础","permalink":"https://note.sdking.fun/categories/c-cpp%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://note.sdking.fun/tags/cpp/"},{"name":"作用域","slug":"作用域","permalink":"https://note.sdking.fun/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"基础","slug":"基础","permalink":"https://note.sdking.fun/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式-Singleton","slug":"DesignPattern/设计模式-Singleton","date":"2021-08-28T09:15:32.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-Singleton/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Singleton/","excerpt":"","text":"动机 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能保证它们的逻辑正确性、以及良好的效率。 如果绕过常规的构造器，提供一种机制来保证一个类只有一个实例。 这应该是类设计者的责任，而不是使用者的责任。定义 保证一个类仅有一个实例，并提供一个该实例的全局访问点。实现1234567891011121314151617class Singleton&#123;public: Singleton(const Singleton &amp;) = delete; static Singleton* getInstance();private: static Singleton* m_instance; Singleton() = delete;&#125;Singleton* Singleton::m_instance = nullptr;Singleton* Singleton::getInstance() &#123; if(m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; retrun m_instance;&#125; 第一个注意的问题 不能让使用者获取到可以直接创建对象的构造函数，如默认构造函数、拷贝构造函数等 需要将他们设置为私有或delete第二个注意的问题 上述版本中getInstance是一个线程不安全的版本，在多线程环境中使用时需要进一步改进改进一：锁保护1234567Singleton* Singleton::getInstance() &#123; Lock lock; if(m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; retrun m_instance;&#125; 这个版本通过锁对m_instance进行了保护，是一个线程安全的版本 但是锁其实仅在第一次创建对象时才会起到真实的保护作用，后续锁就会影响性能 根源是因为锁不紧用在了变量写操作，同时作用到了变量读操作，产生了性能消耗改进二：双检查锁123456789Singleton* Singleton::getInstance() &#123; if(m_instance == nullptr) &#123; Lock lock; if(m_instance == nullptr) &#123; m_instance = new Singleton(); &#125; &#125; retrun m_instance;&#125; 这个版本仅在第一次创建对象时锁才会起作用，后续就不会占用资源，从而避免锁的性能消耗 但是这个版本有一个隐藏很深的bug：由于内存读写reorder导致的锁失效问题 内存读写reorder 多线程是在指令层级抢占cpu时间片的 编译器对代码指令级的优化导致实际执行顺序可能发生改变 在这个例子中m_instance = new Singleton();指令可能分为三个步骤：分配内存、调用构造器、返回内存地址 实际编译器优化后顺序可能为：分配内存、返回内存地址、调用构造器 如果执行到第二个步骤后，另一个线程调用getInstance()就会拿到一个未执行构造的对象指针，引发bug改进三：规避reorder问题 编译器的支持：关键字volatile声明变量m_instance()即可 跨平台支持(c++11)1234567891011121314151617std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) &#123; tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release);//释放内存fence m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 总结 Singleton模式中的实例构造器可以设置为protected以允许子类派生。 Singleton模式一般不需要支持拷贝构造函数和clone接口，因为这可能导致多个对象实例，违背初衷。 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"singleton","slug":"singleton","permalink":"https://note.sdking.fun/tags/singleton/"}],"author":"sdking"},{"title":"设计模式-Builder","slug":"DesignPattern/设计模式-Builder","date":"2021-08-21T09:17:44.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-Builder/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder/","excerpt":"","text":"动机 在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求变化，这个复杂对象的各个部分经常面临这剧烈变化，但是将他们组合在一起的算法却相对稳定。 如何提供一种封装机制来隔离出复杂对象各个部分的变化，从而保持系统中的稳定构建算法不随着需求改变而改变。思路 基类负责构造流程，子类负责各个部分构造的具体实现 这种思想和模板方法非常接近，只不过是专门用于构造对象的版本一：使用模板方法product基类product子类客户程序12345678910111213141516171819202122class House&#123;public: virtual ~House() &#123;&#125; void init() &#123; //管理构造流程 BuildPart1(); for (int i = 0; i &lt; 4; i++)&#123; BuildPart2(); &#125; bool flag=BuildPart3(); if(flag)&#123; BuildPart4(); &#125; BuildPart5(); &#125;protected: virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;;12345678910class StoneHouse: public House&#123;public:protected: //实现具体的构造步骤 virtual void BuildPart1()&#123;&#125; virtual void BuildPart2()&#123;&#125; virtual void BuildPart3()&#123;&#125; virtual void BuildPart4()&#123;&#125; virtual void BuildPart5()&#123;&#125;&#125;;12345int main()&#123; House* phouse = new StoneHouse(); phouse-&gt;init();&#125; 版本二：进一步拆分 product成员复杂 构建流程管理与构建具体实现不想与product其他成员混在一起product类builder基类director类product子类builder子类客户程序12class House&#123;&#125;1234567891011121314class HouseBuilder &#123;public: House* GetResult()&#123; return pHouse; &#125; virtual ~HouseBuilder()&#123;&#125;protected: House* pHouse; virtual void BuildPart1()=0; virtual void BuildPart2()=0; virtual void BuildPart3()=0; virtual void BuildPart4()=0; virtual void BuildPart5()=0;&#125;;1234567891011121314151617181920class HouseDirector&#123;public: HouseDirector(HouseBuilder* pHouseBuilder) ： pHouseBuilder(pHouseBuilder)&#123;&#125; House* Construct()&#123; pHouseBuilder-&gt;BuildPart1(); for (int i = 0; i &lt; 4; i++)&#123; pHouseBuilder-&gt;BuildPart2(); &#125; bool flag=pHouseBuilder-&gt;BuildPart3(); if(flag)&#123; pHouseBuilder-&gt;BuildPart4(); &#125; pHouseBuilder-&gt;BuildPart5(); return pHouseBuilder-&gt;GetResult(); &#125;private: HouseBuilder* pHouseBuilder;&#125;;12class StoneHouse: public House&#123;&#125;;12345678class StoneHouseBuilder: public HouseBuilder&#123;protected: virtual void BuildPart1()&#123;&#125; virtual void BuildPart2()&#123;&#125; virtual void BuildPart3()&#123;&#125; virtual void BuildPart4()&#123;&#125; virtual void BuildPart5()&#123;&#125;&#125;;123456int main()&#123; HouseBuilder* pHouseBuilder = new StoneHouseBuilder(); HouseDirector * pHouseDirector = new HouseDirector(pHouseBuilder); House* pHouse = pHouseDirector-&gt;Construct();&#125; 其中House和HouseBuilder均属于抽象基类，且一一对应总结 类图 Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 变化点在哪里，封装在哪里：Builder模式主要在于应对“负载对象各个部分”的频繁需求变动；其缺点在于难以应对“分步骤”构建算法的需求变动。 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"builder","slug":"builder","permalink":"https://note.sdking.fun/tags/builder/"}],"author":"sdking"},{"title":"cpp之坑-指针引用的模板参数","slug":"cpp-trap/cpp之坑-指针引用的模板参数","date":"2021-08-12T13:44:41.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/cpp-trap/cpp之坑-指针引用的模板参数/","link":"","permalink":"https://note.sdking.fun/blog/cpp-trap/cpp%E4%B9%8B%E5%9D%91-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0/","excerpt":"c++引用与const指针带来的坑","text":"c++引用与const指针带来的坑 起源 一个平平无奇的模板函数 接收两个参数: 类型为T的const引用，一个同样参数的回调函数 直接将第一个参数传入回调12345template&lt;typename T&gt;void foo(const T &amp; data, const std::function&lt;void(const T &amp;)&gt; &amp; callback)&#123; callback(data);&#125; 代码看起来没有什么问题，使用一下12345678int main()&#123; int a = 1; int* ptr = &amp;a; foo&lt;int&gt; (a, [](const int &amp; data)&#123; std::cout &lt;&lt; data &lt;&lt; std::endl; &#125;); foo&lt;int*&gt;(ptr, [](const int* &amp; data)&#123; std::cout &lt;&lt; *data &lt;&lt; std::endl; &#125;); return 0;&#125; 使用g++编译，第一个T为int的foo调用没有问题，但T为int*编译器会报错：找不到匹配的函数 初一看就很奇怪了const引用与const指针 仔细分析下所谓const引用就是意味着变量不能被修改为其他值 那么const引用的指针也即指针不能修改为其他值，即不能指向别的区域 这里就和void* const这样的指针等价了 所以这里编译器应该是针对指针进行了语义转换(或者说内部引用的实现就是通过指针完成的) 这样就可以理解了，模板参数int*会被当做int*const,也就导致我们参数不一致编译失败 如此，修改起来就简单了，把int*改为int*const即可12345678int main()&#123; int a = 1; int* ptr = &amp;a; foo&lt;int&gt; (a, [](const int &amp; data)&#123; std::cout &lt;&lt; data &lt;&lt; std::endl; &#125;); foo&lt;int*const&gt;(ptr, [](const int* const &amp; data)&#123; std::cout &lt;&lt; *data &lt;&lt; std::endl; &#125;); return 0;&#125; 没有const的引用就是普通的指针 进一步验证，把foo对T的引用不使用const 此时模板参数就可以为int*了12345678910111213141516171819202122template&lt;typename T&gt;void foo(const T &amp; data, const std::function&lt;void(const T &amp;)&gt; &amp; cb)&#123; cb(data);&#125;template&lt;typename T&gt;void foo2(T &amp; data, const std::function&lt;void(T &amp;)&gt; &amp; cb)&#123; cb(data);&#125;int main()&#123; int a = 1; int* ptr = &amp;a; foo&lt;int&gt;(a, [](const int &amp; data)&#123; std::cout &lt;&lt; data &lt;&lt; std::endl; &#125;); foo&lt;int*const&gt;(ptr, [](const int* const &amp; data)&#123; std::cout &lt;&lt; *data &lt;&lt; std::endl; &#125;); foo2&lt;int*&gt;(ptr, [](int* &amp; data)&#123; std::cout &lt;&lt; *data &lt;&lt; std::endl; &#125;); return 0;&#125; 以上","categories":[{"name":"cpp-trap","slug":"cpp-trap","permalink":"https://note.sdking.fun/categories/cpp-trap/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://note.sdking.fun/tags/c/"},{"name":"trap","slug":"trap","permalink":"https://note.sdking.fun/tags/trap/"},{"name":"reference","slug":"reference","permalink":"https://note.sdking.fun/tags/reference/"},{"name":"pointer","slug":"pointer","permalink":"https://note.sdking.fun/tags/pointer/"}]},{"title":"程序员的自我修养-目标文件组成(1)","slug":"LinkLoadLibrary/程序员的自我修养-目标文件组成(1)","date":"2021-07-27T14:49:58.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/LinkLoadLibrary/程序员的自我修养-目标文件组成(1)/","link":"","permalink":"https://note.sdking.fun/blog/LinkLoadLibrary/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90(1)/","excerpt":"","text":"目标文件的格式 目标文件：源码编译后但还未链接的文件 在linux平台下目标文件，可执行文件，动态链接库及静态链接库具有相似的文件结构，统称为ELF文件，在windows平台下是PE-COFF格式 目标文件的构成 ELF文件由文件头、代码段(.text)、数据段(.data)及.bss段,具体作用见下图 未初始化的全局变量和局部静态变量默认值都为0，故没必要放在.data段 .bss段只是为未初始化的全局变量和局部静态变量预留位置，并没有内容，在文件中不占用空间(仅需记录预留位置的大小) 数据和代码分离的好处 权限保护。指令区设置为只读， 数据区可读写 提高缓存命中率 便于资源分隔与共享 举例&amp;工具 测试代码 123456789101112131415161718int printf(const char *format, ...);int global_init_var = 84; //.data段int global_uninit_var;void func1(int i)&#123; printf(&quot;%d\\n&quot;, i);&#125;int main(void)&#123; static int static_var = 85; //.data段 static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return a;&#125; 编译： gcc -c test.c -o test.o 查看段大小：size test.o 查看各段简短信息：objdump -h test.o 查看各段详细信息：objdump -s -x -d test.o 如下.data段存储的global_init_var和static_var两个值，对应16进制0x54和0x55 12Contents of section .data: 0000 54000000 55000000 T...U... 使用objcopy将一个二进制文件写入一个elf文件段内 1objcopy -I binary -O elf64-x86-64 -B i386 test.jpeg test.o 在代码中指定变量或函数存储的段 12__attribute__((section(&quot;FOO&quot;))) int global = 42;__attribute__((section(&quot;BAR&quot;))) void foo()&#123;&#125;","categories":[{"name":"程序员的自我修养","slug":"程序员的自我修养","permalink":"https://note.sdking.fun/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}],"tags":[{"name":"objectfile","slug":"objectfile","permalink":"https://note.sdking.fun/tags/objectfile/"},{"name":"ELF","slug":"ELF","permalink":"https://note.sdking.fun/tags/ELF/"},{"name":"linking","slug":"linking","permalink":"https://note.sdking.fun/tags/linking/"}]},{"title":"设计模式-Prototype","slug":"DesignPattern/设计模式-Prototype","date":"2021-07-19T13:47:29.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-Prototype/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Prototype/","excerpt":"","text":"意图用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象 来源 原型模式可以由工厂方法演化而来 具体讲就是将抽象基类Product和Creator合并，并将FactoryMethod改为clone方法 代码示例客户程序抽象类具体类12345678910class MainForm : public Form&#123; ISplitter *prototype;public: MainForm(SplitterFactory *sf) : sf(sf) &#123;&#125; void Button_Click()&#123; ISplitter * splitter = prototype-&gt;clone(); splitter-&gt;split(); &#125;&#125;;1234567class ISplitter&#123;protected: ISplitter()&#123;&#125; ~ISplitter() &#123;&#125; virtual void split() = 0; virtual ISplitter * clone() = 0;&#125;;123456789101112131415class BinarySplitter : public ISplitter&#123;public: void split() override; ISplitter * clone() override()&#123; return new BinarySplitter(); &#125;&#125;;class ImageSplitter : public ISplitter&#123;public: void split() override; ISplitter * clone() override()&#123; return new ImageSplitter(); &#125;&#125;; 注意客户程序中不能直接通过prototype调用split方法 总结 类图 适用性 当一个系统应该独立于它的产品创建、构成和表示时。 当要实例化的类实在运行时指定时。 为了避免创建一个与产品类层次平行的工厂类层次时。 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆他们可能比每次用合适的状态手工实例化该类更方便些。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"factorymethod","slug":"factorymethod","permalink":"https://note.sdking.fun/tags/factorymethod/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"prototype","slug":"prototype","permalink":"https://note.sdking.fun/tags/prototype/"}]},{"title":"hexo-grammar","slug":"snippet/hexo-grammar","date":"2021-07-10T07:32:45.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/snippet/hexo-grammar/","link":"","permalink":"https://note.sdking.fun/blog/snippet/hexo-grammar/","excerpt":"参考文档volantis主题标签系统hexo官方标签系统","text":"参考文档volantis主题标签系统hexo官方标签系统 文本居中 语法，直接调用html1234&#123;% span center small cyan, 曾经有一份真挚的爱情摆在我的面前，但是我没有珍惜， %&#125;&#123;% span center small cyan, 等我失去后才后悔莫及，尘世间最痛苦的事情莫过于此。 %&#125;&#123;% span center small cyan, 如果上天能够给我一个再来一次的机会，我会对那个女孩说三个字：我爱你。 %&#125;&#123;% span center small cyan, 如果非要在这份爱上加一个期限，我希望是。。。。。。一万年！ %&#125; 效果曾经有一份真挚的爱情摆在我的面前，但是我没有珍惜， 等我失去后才后悔莫及，尘世间最痛苦的事情莫过于此。 如果上天能够给我一个再来一次的机会，我会对那个女孩说三个字：我爱你。 如果非要在这份爱上加一个期限，我希望是。。。。。。一万年！","categories":[{"name":"snippet","slug":"snippet","permalink":"https://note.sdking.fun/categories/snippet/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://note.sdking.fun/tags/hexo/"},{"name":"snippet","slug":"snippet","permalink":"https://note.sdking.fun/tags/snippet/"}]},{"title":"设计模式-AbstractFactory","slug":"DesignPattern/设计模式-AbstractFactory","date":"2021-07-04T11:30:31.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-AbstractFactory/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-AbstractFactory/","excerpt":"","text":"动机 在软件系统中，经常面临着一系列相关或相互依赖的对象的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。(注：系列会增多，但系列下的功能不会有变化) 如何绕过常规的对象创建方法(new)，提供一种”封装机制”来避免客户程序和这种”多系列具体对象创建工作”的紧耦合？定义 提供一个接口以创建一系列相关或相互依赖的对象，而无需制定他们的具体类。引出问题 一个程序中读取数据库的内容 读取过程分几个步骤，要用到多个对象，且对象之间有关联性。123456789101112131415class EmployeeDAO&#123;public: //读取数据库的操作流程 vector&lt;EmployeeDO&gt; GetEmployees()&#123; SqlConnection* connection = new SqlConnection(); connection-&gt;ConnectionString = &quot;...&quot;; SqlCommand* command = new SqlCommand(); command-&gt;CommandText=&quot;...&quot;; command-&gt;SetConnection(connection); //注意这里的相关性 SqlDataReader* reader = command-&gt;ExecuteReader(); &#125;&#125;; 上述程序只是对sql数据库进行了支持，为了扩展更多类型的支持，这里需要使用抽象接口 此时就可以使用工厂模式进行重构 使用工厂模式重构product基类product子类creator基类creator子类使用抽象接口12345678910111213141516171819//内部实现忽略class IDBConnection &#123;public: IDBConnection(); ~IDBConnection()&#123;&#125;&#125;class IDBCommand &#123;public: IDBCommand(); ~IDBCommand()&#123;&#125; virtual SetConnection() = 0;&#125;class IDBDataReader &#123;public: IDBDataReader(); ~IDBDataReader()&#123;&#125;&#125;123456789//for Sql serverclass SqlConnection : public IDBConnection &#123;&#125;class SqlCommand: public IDBCommand &#123;&#125;class SqlDataReader : public IDBReader &#123;&#125;//for Oracle serverclass OracleConnection : public IDBConnection &#123;&#125;class OracleCommand: public IDBCommand &#123;&#125;class OracleDataReader : public IDBDataReader &#123;&#125;123456789101112131415161718192021//内部实现忽略class IDBConnectionFactory &#123;public: IDBConnectionFactory(); ~IDBConnectionFactory()&#123;&#125; virtual IDBConnection* CreateIDBConnection() = 0;&#125;class IDBCommandFactory &#123;public: IDBCommandFactory(); ~IDBCommandFactory()&#123;&#125; virtual IDBCommand* CreateIDBCommand() = 0;&#125;class IDBDataReaderFactory &#123;public: IDBDataReaderFactory(); ~IDBDataReaderFactory()&#123;&#125; virtual IDBDataReader* CreateIDBDataReader() = 0;&#125;1234567891011121314151617181920212223//内部实现忽略//for sql serverclass sqlConnectionFactory : public IDBConnectionFactory&#123; IDBConnection* CreateIDBConnection() override &#123;...&#125;&#125;class sqlCommandFactory : public IDBCommandFactory &#123; IDBCommand* CreateIDBCommand() override &#123;...&#125;&#125;class sqlDataReaderFactory : public IDBDataReaderFactory &#123; IDBDataReader* CreateIDBDataReader() override &#123;...&#125;&#125;//for Oracle serverclass OracleConnectionFactory : public IDBConnectionFactory&#123; IDBConnection* CreateIDBConnection() override &#123;...&#125;&#125;class OracleCommandFactory : public IDBCommandFactory &#123; IDBCommand* CreateIDBCommand() override &#123;...&#125;&#125;class OracleDataReaderFactory : public IDBDataReaderFactory &#123; IDBDataReader* CreateIDBDataReader() override &#123;...&#125;&#125;123456789101112131415161718class EmployeeDAO&#123; //通过EmployeeDAO的构造函数初始化一下三个抽象指针 IDBConnectionFactory * connectFactory; IDBCommandFactory * commandFactory; IDBDataReaderFactory * dataReaderFactory;public: //读取数据库的操作流程 vector&lt;EmployeeDO&gt; GetEmployees()&#123; IDBConnection* connection = connectFactory-&gt;CreateIDBConnection(); connection-&gt;ConnectionString = &quot;...&quot;; IDBCommand* command = commandFactory-&gt;CreateIDBCommand(); command-&gt;CommandText=&quot;...&quot;; command-&gt;SetConnection(connection); //注意这里的相关性 IDBDataReader* reader = dataReaderFactory-&gt;CreateIDBDataReader(); &#125;&#125;; 代码写到这里似乎已经不错了，抽象接口和具体实现已经完成了隔离。 这里就要再次提到开头强调的一系列相关或相互依赖，在本例中，IDBCommand::SetConnection依赖于IDBConnection对象，具有关联性 具体讲就是这里三个对象应该是同一种数据库，属于高内聚的对象。123IDBConnectionFactory * connectFactory;IDBCommandFactory * commandFactory;IDBDataReaderFactory * dataReaderFactory; 如何处理这种情况就引出抽象工厂。使用抽象工厂重构 既然上述三个工厂具有相关性，那么为什么不用一个工厂来完成呢product基类product子类creator基类creator子类使用抽象接口12345678910111213141516171819//内部实现忽略class IDBConnection &#123;public: IDBConnection(); ~IDBConnection()&#123;&#125;&#125;class IDBCommand &#123;public: IDBCommand(); ~IDBCommand()&#123;&#125; virtual SetConnection() = 0;&#125;class IDBDataReader &#123;public: IDBDataReader(); ~IDBDataReader()&#123;&#125;&#125;123456789//for Sql serverclass SqlConnection : public IDBConnection &#123;&#125;class SqlCommand: public IDBCommand &#123;&#125;class SqlDataReader : public IDBReader &#123;&#125;//for Oracle serverclass OracleConnection : public IDBConnection &#123;&#125;class OracleCommand: public IDBCommand &#123;&#125;class OracleDataReader : public IDBDataReader &#123;&#125;123456789//内部实现忽略class IDBFactory &#123;public: IDBFactory(); ~IDBFactory()&#123;&#125; virtual IDBConnection* CreateIDBConnection() = 0; virtual IDBCommand* CreateIDBCommand() = 0; virtual IDBDataReader* CreateIDBDataReader() = 0;&#125;123456789101112131415//内部实现忽略//for sql serverclass SqlFactory : public IDBFactory&#123; IDBConnection* CreateIDBConnection() override &#123;...&#125; IDBCommand* CreateIDBCommand() override &#123;...&#125; IDBDataReader* CreateIDBDataReader() override &#123;...&#125;&#125;//for Oracle serverclass OracleFactory : public IDBFactory&#123; IDBConnection* CreateIDBConnection() override &#123;...&#125; IDBCommand* CreateIDBCommand() override &#123;...&#125; IDBDataReader* CreateIDBDataReader() override &#123;...&#125;&#125;12345678910111213141516class EmployeeDAO&#123; //通过EmployeeDAO的构造函数初始化一下三个抽象指针 IDBFactory * factory;public: //读取数据库的操作流程 vector&lt;EmployeeDO&gt; GetEmployees()&#123; IDBConnection* connection = factory-&gt;CreateIDBConnection(); connection-&gt;ConnectionString = &quot;...&quot;; IDBCommand* command = factory-&gt;CreateIDBCommand(); command-&gt;CommandText=&quot;...&quot;; command-&gt;SetConnection(connection); //注意这里的相关性 IDBDataReader* reader = factory-&gt;CreateIDBDataReader(); &#125;&#125;; 通过将高内聚的对象使用放在同一个工厂内，从而实现高内聚，松耦合。总结 类图 client -&gt; EmployeeDAO AbstactProduct -&gt; [IDBConnection] or [IDBCommand] or [IDataReader] AbstactFactory -&gt; IDBFactory 如果没有应对多系列对象构建的需求变化，则没有必要使用抽象工厂模式，这时候使用简单工厂模式即可 系列对象指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖(如上述例子中的sql和oracle) 抽象工厂模式主要在于应对新系列的需求变动，其缺点在于难以应对新对象的需求变动。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"abstractfactory","slug":"abstractfactory","permalink":"https://note.sdking.fun/tags/abstractfactory/"},{"name":"factorymethod","slug":"factorymethod","permalink":"https://note.sdking.fun/tags/factorymethod/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"程序员的自我修养-编译链接","slug":"LinkLoadLibrary/程序员的自我修养-编译链接","date":"2021-07-03T09:25:29.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/LinkLoadLibrary/程序员的自我修养-编译链接/","link":"","permalink":"https://note.sdking.fun/blog/LinkLoadLibrary/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/","excerpt":"&lt;&lt;程序员的自我修养–链接、装载与库&gt;&gt; 读书笔记.","text":"&lt;&lt;程序员的自我修养–链接、装载与库&gt;&gt; 读书笔记. 程序构建(Build)流程 编译(Compilation)流程 链接(Linking)流程 链接的主要内容就是把各个模块之间相互引用的部分(接口&amp;变量)处理好 主要包括地址和空间分配(Address and Storage Allocation)，符号决议(Symbol Resolution)和重定位(Relocation)等这些步骤。 具体来说就是要将编译得到的目标文件和库链接形成最终的可执行文件","categories":[{"name":"程序员的自我修养","slug":"程序员的自我修养","permalink":"https://note.sdking.fun/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}],"tags":[{"name":"linking","slug":"linking","permalink":"https://note.sdking.fun/tags/linking/"},{"name":"prepressing","slug":"prepressing","permalink":"https://note.sdking.fun/tags/prepressing/"},{"name":"compile","slug":"compile","permalink":"https://note.sdking.fun/tags/compile/"},{"name":"assembly","slug":"assembly","permalink":"https://note.sdking.fun/tags/assembly/"}],"author":"sdking"},{"title":"设计模式-FactoryMethod","slug":"DesignPattern/设计模式-FactoryMethod","date":"2021-06-29T13:44:59.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-FactoryMethod/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-FactoryMethod/","excerpt":"","text":"动机 抽象框架感知抽象类，抽象框架必须实例化一个具体类，但抽象框架不知道哪个类要被实例化。 绕开常规创建对象方法new，提供一种”封装机制”来避免客户程序和具体对象的紧耦合 定义 意图定义一个用于创建对象的接口，让子类决定实例化哪个类。 使一个类的实例化延迟到其子类。 引出问题 一个用于文件分割的程序 变化在于对于不同的文件有不同的分割操作 以下代码中忽略了实际工程中的参数细节 客户程序抽象类具体类123456789101112class MainForm : public Form&#123;public: void Button1_Click()&#123; ISplitter * splitter1= new BinarySplitter();//依赖具体类 splitter1-&gt;split(); &#125; void Button2_Click()&#123; ISplitter * splitter2= new ImageSplitter();//依赖具体类 splitter1-&gt;split(); &#125;&#125;;123456class Splitter&#123;protected: vitural split() = 0; ~Splitter() &#123;&#125;&#125;;123456789class BinarySplitter : public Splitter&#123;protected: split();&#125;;class ImageSplitter : public Splitter&#123;protected: split();&#125;; 该例子中MainForm作为高层模块中依赖于底层模块的变化，违背了依赖倒置原则 具体讲就是MainForm作为抽象功能却依赖的具体的对象BinarySplitter和ImageSplitter 思路：隐藏变化(具体实现) MainForm中必须要用到一个实现，但我们又要隐藏他的实现细节 利用虚函数的多态性，使用一个抽象接口来实例化具体类 客户程序工厂类123456789class MainForm : public Form&#123;public: void Button_Click()&#123; SplitterFactory sf; ISplitter * splitter = sf.CreateSplitter();//依赖具体类 splitter-&gt;split(); &#125;&#125;;123456class SplitterFactory&#123;public: ISplitter * CreateSplitter()&#123; return new BinarySplitter(); //or new ImageSplitter() &#125;&#125;; 这一版代码，虽然看似在MainForm隐藏了具体实现，但他依赖的SplitterFactory类还是要依赖具体实现，所以还需要进一步改造 将实现放在未来 将SplitterFactory::CreateSplitter定义为纯虚函数 客户程序工厂基类工厂子类123456789class MainForm : public Form&#123;public: void Button_Click()&#123; SplitterFactory *sf; ISplitter * splitter = sf-&gt;CreateSplitter(); splitter-&gt;split(); &#125;&#125;;12345class SplitterFactory&#123;public: virtual ISplitter * CreateSplitter() = 0; ~SplitterFactory()&#123;&#125;&#125;;12345678910111213class BinarySplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new BinarySplitter(); &#125;&#125;;class ImageSplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new ImageSplitter(); &#125;&#125;; 此时，MainForm就完全不依赖具体的实现了，所有的方法都是抽象的 那么新的问题来了，MainForm中的sf如何初始化呢 最终的版本 通常是将sf作为MainForm的成员变量，因为他可能被多次使用 并通过MainForm的构造函数初始化客户程序工厂基类工厂子类12345678910class MainForm : public Form&#123; SplitterFactory *sf;public: MainForm(SplitterFactory *sf) : sf(sf) &#123;&#125; void Button_Click()&#123; ISplitter * splitter = sf-&gt;CreateSplitter(); splitter-&gt;split(); &#125;&#125;;12345class SplitterFactory&#123;public: virtual ISplitter * CreateSplitter() = 0; ~SplitterFactory()&#123;&#125;&#125;;12345678910111213class BinarySplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new BinarySplitter(); &#125;&#125;;class ImageSplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new ImageSplitter(); &#125;&#125;; 一点疑问既然MainForm可以传入多态指针，那为什么不直接传入ISplitter*呢，何必绕一圈？猜想可能是sf中未来可能集成各种不同对象的create 总结 类图 以上。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"factorymethod","slug":"factorymethod","permalink":"https://note.sdking.fun/tags/factorymethod/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"sdking"},{"title":"设计模式-Bridge","slug":"DesignPattern/设计模式-Bridge","date":"2021-06-22T21:07:03.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-Bridge/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Bridge/","excerpt":"","text":"以下笔记摘录自李建忠老师的&lt;&lt;c++设计模式&gt;&gt;和书籍&lt;&lt;设计模式&gt;&gt; 动机 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。定义 将抽象部分(业务功能)与实现部分(平台兼容)分离，使他们都可以独立的变化。原始代码抽象类平台实现业务抽象使用 抽象类中包含了两个维度的接口12345678910111213class Messager&#123;public: virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual ~Messager()&#123;&#125;&#125;; 123456789101112131415161718192021222324252627282930313233class PCMessagerBase : public Messager&#123;public: virtual void PlaySound()&#123; //********** &#125; virtual void DrawShape()&#123; //********** &#125; virtual void WriteText()&#123; //********** &#125; virtual void Connect()&#123; //********** &#125;&#125;;class MobileMessagerBase : public Messager&#123;public: virtual void PlaySound()&#123; //========== &#125; virtual void DrawShape()&#123; //========== &#125; virtual void WriteText()&#123; //========== &#125; virtual void Connect()&#123; //========== &#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class PCMessagerLite : public PCMessagerBase &#123;public: virtual void Login(string username, string password)&#123; PCMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; PCMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; PCMessagerBase::DrawShape(); //........ &#125;&#125;;class PCMessagerPerfect : public PCMessagerBase &#123;public: virtual void Login(string username, string password)&#123; PCMessagerBase::PlaySound(); //******** PCMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; PCMessagerBase::PlaySound(); //******** PCMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; PCMessagerBase::PlaySound(); //******** PCMessagerBase::DrawShape(); //........ &#125;&#125;;class MobileMessagerLite : public MobileMessagerBase &#123;public: virtual void Login(string username, string password)&#123; MobileMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; MobileMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; MobileMessagerBase::DrawShape(); //........ &#125;&#125;;class MobileMessagerPerfect : public MobileMessagerBase &#123;public: virtual void Login(string username, string password)&#123; MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::DrawShape(); //........ &#125;&#125;;1234void Process()&#123; //编译时装配 Messager *m = new MobileMessagerPerfect();&#125; 重构代码抽象类拆分并组合平台实现业务抽象使用 抽象类中包含了两个维度的接口1234567891011121314151617181920class Messager&#123;protected: MessagerImp * messageImp;public: Messager(MessagerImp *imp) : messageImp(imp) &#123;&#125; virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual ~Messager()&#123;&#125;&#125;;class MessagerImp&#123;public: virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual ~MessagerImp()&#123;&#125;&#125;; 12345678910111213141516171819202122232425262728293031class PCMessagerImp : public MessagerImp&#123;public: virtual void PlaySound()&#123; //********** &#125; virtual void DrawShape()&#123; //********** &#125; virtual void WriteText()&#123; //********** &#125; virtual void Connect()&#123; //********** &#125;&#125;;class MobileMessagerImp : public MessagerImp&#123;public: virtual void PlaySound()&#123; //========== &#125; virtual void DrawShape()&#123; //========== &#125; virtual void WriteText()&#123; //========== &#125; virtual void Connect()&#123; //========== &#125;&#125;;123456789101112131415161718192021222324252627282930313233343536373839class MessagerLite : public Messager &#123;public: MessagerLite(MessagerImp* mImp) : Messager(mImp) &#123;&#125; virtual void Login(string username, string password)&#123; messageImp-&gt;Connect(); //........ &#125; virtual void SendMessage(string message)&#123; messageImp-&gt;CWriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; messageImp-&gt;CDrawShape(); //........ &#125;&#125;;class MessagerPerfect : public Messager &#123;public: MessagerPerfect(MessagerImp* mImp) : Messager(mImp) &#123;&#125; virtual void Login(string username, string password)&#123; messageImp-&gt;CPlaySound(); //******** messageImp-&gt;CConnect(); //........ &#125; virtual void SendMessage(string message)&#123; messageImp-&gt;CPlaySound(); //******** messageImp-&gt;CWriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; messageImp-&gt;CPlaySound(); //******** messageImp-&gt;CDrawShape(); //........ &#125;&#125;; 这里也可以通过抽象工厂自动完成Imp的实现123456void Process()&#123; //运行时装配 MessagerImp* mImp=new PCMessagerImp(); MessagerLite *mp =new MessagerLite(mImp); MessagerPerfect *ml =new MessagerPerfect(mImp);&#125; 总结 结构图","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"bridge","slug":"bridge","permalink":"https://note.sdking.fun/tags/bridge/"}],"author":"sdking"},{"title":"设计模式-Decorator","slug":"DesignPattern/设计模式-Decorator","date":"2021-06-08T13:13:15.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/DesignPattern/设计模式-Decorator/","link":"","permalink":"https://note.sdking.fun/blog/DesignPattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Decorator/","excerpt":"","text":"以下笔记摘录自李建忠老师的&lt;&lt;c++设计模式&gt;&gt;和书籍&lt;&lt;设计模式&gt;&gt; 动机希望给某个对象而不是整个类添加一些功能，或者说动态的给一个对象添加一些额外的职责 原始代码业务操作主体类扩展操作：加密更多可能的组合或扩展：加密、缓冲12345678class Stream&#123;public: virtual char Read(int number) = 0; virtual void Seek(int position) = 0; virtual void Write(char data) = 0; virtual ~Stream() &#123;&#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041class FileStream : public Stream&#123;public: virtual char Read(int number) &#123; //读文件流 &#125; virtual void Seek(int position)&#123; //定位文件流 &#125; virtual void Write(char data)&#123; //写文件流 &#125;&#125;;class NetworkStream : public Stream&#123;public: virtual char Read(int number) &#123; //读网络流 &#125; virtual void Seek(int position)&#123; //定位网络流 &#125; virtual void Write(char data)&#123; //写网络流 &#125;&#125;;class MemoryStream : public Stream&#123;public: virtual char Read(int number) &#123; //读内存流 &#125; virtual void Seek(int position)&#123; //定位内存流 &#125; virtual void Write(char data)&#123; //写内存流 &#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class CryptoFileStream : public FileStream&#123;public: virtual char Read(int number) &#123; //额外的加密操作... FileStream::Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... FileStream::Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... FileStream::Write(data); //额外的加密操作... &#125;&#125;;class CryptoNetworkStream : public NetworkStream&#123;public: virtual char Read(int number) &#123; //额外的加密操作... NetworkStream::Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... NetworkStream::Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... NetworkStream::Write(data); //额外的加密操作... &#125;&#125;;class CryptoMemoryStream : public MemoryStream&#123;public: virtual char Read(int number) &#123; //额外的加密操作... MemoryStream::Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... MemoryStream::Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... MemoryStream::Write(data); //额外的加密操作... &#125;&#125;;1234567891011121314151617181920class BufferdFileStream : public FileStream &#123; //...&#125;class BufferdNetworkStream : public NetworkStream &#123; //...&#125;class BufferdMemoryStream : public MemoryStream &#123; //...&#125;class CryptoBufferdFileStream : public BufferdFileStream &#123; //...&#125;class CryptoBufferdNetworkStream : public BufferdNetworkStream &#123; //...&#125;class CryptoBufferdMemoryStream : public BufferdMemoryStream &#123; //...&#125; 类的继承关系及扩展组合方式如下： 可以看到随着扩展种类增多，各种组合导致类的数量急剧增加 使用代码如下：12345//编译时装配FileStream * s1 = new FileStream();CryptoFileStream * s1 = new CryptoFileStream();BufferdFileStream * s2 = new BufferdFileStream();CryptoBufferdFileStream * s3 = new CryptoBufferdFileStream(); 重构： 第一个版本，重要的思路转换 扩展操作类由继承改为组合 CryptoFileStreamCryptoNetworkStreamCryptoMemoryStream1234567891011121314151617181920class CryptoFileStream&#123; FileStream * stream;public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;1234567891011121314151617181920class CryptoNetworkStream&#123; NetworkStream * stream;public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;1234567891011121314151617181920class CryptoMemoryStream&#123; MemoryStream * stream;public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 重构： 第二个版本，充分利用抽象类 扩展操作类子类对象指针改为基类指针，通过不同的初始化方式应不同的子类 CryptoFileStreamCryptoNetworkStreamCryptoMemoryStream1234567891011121314151617181920class CryptoFileStream&#123; Stream * stream; // = new FileStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;123456789101112131415161718192021class CryptoNetworkStream&#123; Stream * stream; // = new NetworkStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;123456789101112131415161718192021class CryptoMemoryStream&#123; Stream * stream; // = new MemoryStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 重构： 第三个版本，合并简化 第二个重构版本中可以发现这三个类其实是完全一样，以合并为一个 1234567891011121314151617181920class CryptoStream&#123; Stream * stream; // = new FileStream(); or new NetworkStream(); or new MemoryStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 为保留基类虚函数的规范，这个类还要继承Stream类，同时添加了构造函数 123456789101112131415161718192021class CryptoStream : public Stream&#123; Stream * stream; // = new FileStream(); or new NetworkStream(); or new MemoryStream();public: CryptoStream(Stream * stm) : stream(stm) &#123;&#125; virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 会发现这个类既继承了基类，又含有基类指针成员，这也是decorator模式的一个重要标志 同理buffered扩展就重构为 123456789101112131415161718class BufferedStream : public Stream&#123; Stream * stream; // = new FileStream(); or new NetworkStream(); or new MemoryStream();public: BufferedStream(Stream * stm) : stream(stm) &#123;&#125; virtual char Read(int number) &#123; //额外的buffer操作... stream-&gt;Read(number); &#125; virtual void Seek(int position)&#123; //额外的buffer操作... stream-&gt;Seek(position); &#125; virtual void Write(char data)&#123; //额外的buffer操作... stream-&gt;Write(data); &#125;&#125;; 重构： 最后的版本，锦上添花 可以发现第三个版本中CryptoStream和BufferdStream中都有成员指针，那么就可以尝试将其往底层提取 一个直接的办法是放置在抽象类Stream中，但这样对三个主题类而言是多余的 所以可以再封装一个类DecoratorStream 12345678910111213141516171819class DecoratorStream : public Stream&#123; Stream * stream;public: DecoratorStream(Stream * stm) : stream(stm) &#123;&#125;&#125;;//扩展操作继承DecoratorStreamclass CryptoStream : public DecoratorStream&#123;public: CryptoStream(Stream * stm) : DecoratorStream(stm) &#123;&#125;&#125;；class BufferedStream : public DecoratorStream&#123;public: BufferedStream(Stream * stm) : DecoratorStream(stm) &#123;&#125;&#125;； 使用代码如下： 12345//运行时装配FileStream * s1 = new FileStream();CryptoStream * s2 = new CryptoStream(s1); //针对FileStream加密BufferdStream * s3 = new BufferdStream(s1); //针对FileStream缓冲BufferdStream * s4 = new BufferdStream(s2); //针对FileStream既缓冲又加密 总结 根源分析：某些情况下”过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质(扩展类中调用子类的Read，Seek，Write)，使得这种扩展方式缺乏灵活性。 模式定义：动态(组合)的给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类(继承)更为灵活(消除重复代码&amp;减少子类个数)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"decorator","slug":"decorator","permalink":"https://note.sdking.fun/tags/decorator/"}],"author":"sdking"},{"title":"manim-第一个程序","slug":"manim/manim-第一个程序","date":"2021-06-05T13:09:00.000Z","updated":"2021-11-25T14:26:22.368Z","comments":true,"path":"blog/manim/manim-第一个程序/","link":"","permalink":"https://note.sdking.fun/blog/manim/manim-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","excerpt":"Manim is an engine for precise programatic animations","text":"Manim is an engine for precise programatic animations clone仓库1git clone https://github.com/3b1b/manim.git 运行demo12cd manimmanimgl example_scenes.py OpeningManimExample 编写一个 在manim目录下新建python文件demo.py，代码如下 1234567891011121314from manimlib.imports import *class SquareToCircle(Scene): def construct(self): circle = Circle() circle.set_fill(BLUE, opacity=0.5) circle.set_stroke(BLUE_A, width=4) square = Square() self.play(ShowCreation(square)) self.play(ReplacementTransform(square, circle)) self.wait() exit() 运行程序，执行manim demo.py SquareToCircle，就会展示如下动画 执行manim demo.py SquareToCircle -wm可以在videos目录下生成视屏文件 代码解析 定义场景类： 需要继承自场景类Scene override函数：construct 12class SquareToCircle(Scene): def construct(self): 场景元素添加并设置： 1234circle = Circle()circle.set_fill(BLUE, opacity=0.5)circle.set_stroke(BLUE_A, width=4)square = Square() 动画定义及播放： 12self.play(ShowCreation(square))self.play(ReplacementTransform(square, circle)) 以上。","categories":[{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/categories/manim/"}],"tags":[{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/tags/manim/"},{"name":"math","slug":"math","permalink":"https://note.sdking.fun/tags/math/"},{"name":"python","slug":"python","permalink":"https://note.sdking.fun/tags/python/"}]}],"categories":[{"name":"life","slug":"life","permalink":"https://note.sdking.fun/categories/life/"},{"name":"c/cpp基础","slug":"c-cpp基础","permalink":"https://note.sdking.fun/categories/c-cpp%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"cpp-trap","slug":"cpp-trap","permalink":"https://note.sdking.fun/categories/cpp-trap/"},{"name":"程序员的自我修养","slug":"程序员的自我修养","permalink":"https://note.sdking.fun/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"},{"name":"snippet","slug":"snippet","permalink":"https://note.sdking.fun/categories/snippet/"},{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/categories/manim/"}],"tags":[{"name":"music","slug":"music","permalink":"https://note.sdking.fun/tags/music/"},{"name":"cpp","slug":"cpp","permalink":"https://note.sdking.fun/tags/cpp/"},{"name":"作用域","slug":"作用域","permalink":"https://note.sdking.fun/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"基础","slug":"基础","permalink":"https://note.sdking.fun/tags/%E5%9F%BA%E7%A1%80/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"singleton","slug":"singleton","permalink":"https://note.sdking.fun/tags/singleton/"},{"name":"builder","slug":"builder","permalink":"https://note.sdking.fun/tags/builder/"},{"name":"c++","slug":"c","permalink":"https://note.sdking.fun/tags/c/"},{"name":"trap","slug":"trap","permalink":"https://note.sdking.fun/tags/trap/"},{"name":"reference","slug":"reference","permalink":"https://note.sdking.fun/tags/reference/"},{"name":"pointer","slug":"pointer","permalink":"https://note.sdking.fun/tags/pointer/"},{"name":"objectfile","slug":"objectfile","permalink":"https://note.sdking.fun/tags/objectfile/"},{"name":"ELF","slug":"ELF","permalink":"https://note.sdking.fun/tags/ELF/"},{"name":"linking","slug":"linking","permalink":"https://note.sdking.fun/tags/linking/"},{"name":"factorymethod","slug":"factorymethod","permalink":"https://note.sdking.fun/tags/factorymethod/"},{"name":"prototype","slug":"prototype","permalink":"https://note.sdking.fun/tags/prototype/"},{"name":"hexo","slug":"hexo","permalink":"https://note.sdking.fun/tags/hexo/"},{"name":"snippet","slug":"snippet","permalink":"https://note.sdking.fun/tags/snippet/"},{"name":"abstractfactory","slug":"abstractfactory","permalink":"https://note.sdking.fun/tags/abstractfactory/"},{"name":"prepressing","slug":"prepressing","permalink":"https://note.sdking.fun/tags/prepressing/"},{"name":"compile","slug":"compile","permalink":"https://note.sdking.fun/tags/compile/"},{"name":"assembly","slug":"assembly","permalink":"https://note.sdking.fun/tags/assembly/"},{"name":"bridge","slug":"bridge","permalink":"https://note.sdking.fun/tags/bridge/"},{"name":"decorator","slug":"decorator","permalink":"https://note.sdking.fun/tags/decorator/"},{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/tags/manim/"},{"name":"math","slug":"math","permalink":"https://note.sdking.fun/tags/math/"},{"name":"python","slug":"python","permalink":"https://note.sdking.fun/tags/python/"}]}