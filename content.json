{"meta":{"title":"云处安","subtitle":"sdking的笔记本","description":"","author":"Sdking Tsing","url":"https://note.sdking.fun","root":"/"},"pages":[{"title":"about","date":"2021-06-23T14:36:16.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"about/index.html","permalink":"https://note.sdking.fun/about/index.html","excerpt":"","text":"","author":"sdking"},{"title":"分类","date":"2021-06-08T13:11:20.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"categories/index.html","permalink":"https://note.sdking.fun/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-07-04T10:10:04.456Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"friends/index.html","permalink":"https://note.sdking.fun/friends/index.html","excerpt":"","text":""},{"title":"more","date":"2021-06-10T15:08:44.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"more/index.html","permalink":"https://note.sdking.fun/more/index.html","excerpt":"","text":"","author":"sdking"},{"title":"notes","date":"2021-06-10T15:02:17.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"notes/index.html","permalink":"https://note.sdking.fun/notes/index.html","excerpt":"","text":"","author":"sdking"},{"title":"标签","date":"2021-06-08T13:15:24.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"tags/index.html","permalink":"https://note.sdking.fun/tags/index.html","excerpt":"","text":"","author":"sdking"}],"posts":[{"title":"程序员的自我修养-编译链接","slug":"程序员的自我修养-编译链接","date":"2021-07-03T09:25:29.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"blog/程序员的自我修养-编译链接/","link":"","permalink":"https://note.sdking.fun/blog/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/","excerpt":"&lt;&lt;程序员的自我修养–链接、装载与库&gt;&gt; 读书笔记.","text":"&lt;&lt;程序员的自我修养–链接、装载与库&gt;&gt; 读书笔记. 程序构建(Build)流程 编译(Compilation)流程 链接(Linking)流程TODO","categories":[{"name":"程序员的自我修养","slug":"程序员的自我修养","permalink":"https://note.sdking.fun/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"}],"tags":[{"name":"prepressing","slug":"prepressing","permalink":"https://note.sdking.fun/tags/prepressing/"},{"name":"compile","slug":"compile","permalink":"https://note.sdking.fun/tags/compile/"},{"name":"assembly","slug":"assembly","permalink":"https://note.sdking.fun/tags/assembly/"},{"name":"link","slug":"link","permalink":"https://note.sdking.fun/tags/link/"}],"author":"sdking"},{"title":"设计模式-FactoryMethod","slug":"设计模式-FactoryMethod","date":"2021-06-29T13:44:59.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"blog/设计模式-FactoryMethod/","link":"","permalink":"https://note.sdking.fun/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-FactoryMethod/","excerpt":"","text":"动机 抽象框架感知抽象类，抽象框架必须实例化一个具体类，但抽象框架不知道哪个类要被实例化。 绕开常规创建对象方法new，提供一种”封装机制”来避免客户程序和具体对象的紧耦合 定义 意图定义一个用于创建对象的接口，让子类决定实例化哪个类。 使一个类的实例化延迟到其子类。 引出问题 一个用于文件分割的程序 变化在于对于不同的文件有不同的分割操作 以下代码中忽略了实际工程中的参数细节 客户程序抽象类具体类123456789101112class MainForm : public Form&#123;public: void Button1_Click()&#123; ISplitter * splitter1= new BinarySplitter();//依赖具体类 splitter1-&gt;split(); &#125; void Button2_Click()&#123; ISplitter * splitter2= new ImageSplitter();//依赖具体类 splitter1-&gt;split(); &#125;&#125;;123456class Splitter&#123;protected: vitural split() = 0; ~Splitter() &#123;&#125;&#125;;123456789class BinarySplitter : public Splitter&#123;protected: split();&#125;;class ImageSplitter : public Splitter&#123;protected: split();&#125;; 该例子中MainForm作为高层模块中依赖于底层模块的变化，违背了依赖倒置原则 具体讲就是MainForm作为抽象功能却依赖的具体的对象BinarySplitter和ImageSplitter 思路：隐藏变化(具体实现) MainForm中必须要用到一个实现，但我们又要隐藏他的实现细节 利用虚函数的多态性，使用一个抽象接口来实例化具体类 客户程序工厂类123456789class MainForm : public Form&#123;public: void Button_Click()&#123; SplitterFactory sf; ISplitter * splitter = sf.CreateSplitter();//依赖具体类 splitter-&gt;split(); &#125;&#125;;123456class SplitterFactory&#123;public: ISplitter * CreateSplitter()&#123; return new BinarySplitter(); //or new ImageSplitter() &#125;&#125;; 这一版代码，虽然看似在MainForm隐藏了具体实现，但他依赖的SplitterFactory类还是要依赖具体实现，所以还需要进一步改造 将实现放在未来 将SplitterFactory::CreateSplitter定义为纯虚函数 客户程序工厂基类工厂子类123456789class MainForm : public Form&#123;public: void Button_Click()&#123; SplitterFactory *sf; ISplitter * splitter = sf-&gt;CreateSplitter(); splitter-&gt;split(); &#125;&#125;;12345class SplitterFactory&#123;public: virtual ISplitter * CreateSplitter() = 0; ~SplitterFactory()&#123;&#125;&#125;;12345678910111213class BinarySplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new BinarySplitter(); &#125;&#125;;class ImageSplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new ImageSplitter(); &#125;&#125;; 此时，MainForm就完全不依赖具体的实现了，所有的方法都是抽象的 那么新的问题来了，MainForm中的sf如何初始化呢 最终的版本 通常是将sf作为MainForm的成员变量，因为他可能被多次使用 并通过MainForm的构造函数初始化客户程序工厂基类工厂子类12345678910class MainForm : public Form&#123; SplitterFactory *sf;public: MainForm(SplitterFactory *sf) : sf(sf) &#123;&#125; void Button_Click()&#123; ISplitter * splitter = sf-&gt;CreateSplitter(); splitter-&gt;split(); &#125;&#125;;12345class SplitterFactory&#123;public: virtual ISplitter * CreateSplitter() = 0; ~SplitterFactory()&#123;&#125;&#125;;12345678910111213class BinarySplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new BinarySplitter(); &#125;&#125;;class ImageSplitterFactory : SplitterFactory&#123;public: ISplitter * CreateSplitter() &#123; return new ImageSplitter(); &#125;&#125;; 一点疑问既然MainForm可以传入多态指针，那为什么不直接传入ISplitter*呢，何必绕一圈？猜想可能是sf中未来可能集成各种不同对象的create 总结 类图 以上。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"factorymethod","slug":"factorymethod","permalink":"https://note.sdking.fun/tags/factorymethod/"}],"author":"sdking"},{"title":"设计模式-Bridge","slug":"设计模式-Bridge","date":"2021-06-22T21:07:03.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"blog/设计模式-Bridge/","link":"","permalink":"https://note.sdking.fun/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Bridge/","excerpt":"","text":"以下笔记摘录自李建忠老师的&lt;&lt;c++设计模式&gt;&gt;和书籍&lt;&lt;设计模式&gt;&gt; 动机 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。定义 将抽象部分(业务功能)与实现部分(平台兼容)分离，使他们都可以独立的变化。原始代码抽象类平台实现业务抽象使用 抽象类中包含了两个维度的接口12345678910111213class Messager&#123;public: virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual ~Messager()&#123;&#125;&#125;; 123456789101112131415161718192021222324252627282930313233class PCMessagerBase : public Messager&#123;public: virtual void PlaySound()&#123; //********** &#125; virtual void DrawShape()&#123; //********** &#125; virtual void WriteText()&#123; //********** &#125; virtual void Connect()&#123; //********** &#125;&#125;;class MobileMessagerBase : public Messager&#123;public: virtual void PlaySound()&#123; //========== &#125; virtual void DrawShape()&#123; //========== &#125; virtual void WriteText()&#123; //========== &#125; virtual void Connect()&#123; //========== &#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class PCMessagerLite : public PCMessagerBase &#123;public: virtual void Login(string username, string password)&#123; PCMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; PCMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; PCMessagerBase::DrawShape(); //........ &#125;&#125;;class PCMessagerPerfect : public PCMessagerBase &#123;public: virtual void Login(string username, string password)&#123; PCMessagerBase::PlaySound(); //******** PCMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; PCMessagerBase::PlaySound(); //******** PCMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; PCMessagerBase::PlaySound(); //******** PCMessagerBase::DrawShape(); //........ &#125;&#125;;class MobileMessagerLite : public MobileMessagerBase &#123;public: virtual void Login(string username, string password)&#123; MobileMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; MobileMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; MobileMessagerBase::DrawShape(); //........ &#125;&#125;;class MobileMessagerPerfect : public MobileMessagerBase &#123;public: virtual void Login(string username, string password)&#123; MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::Connect(); //........ &#125; virtual void SendMessage(string message)&#123; MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::WriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::DrawShape(); //........ &#125;&#125;;1234void Process()&#123; //编译时装配 Messager *m = new MobileMessagerPerfect();&#125; 重构代码抽象类拆分并组合平台实现业务抽象使用 抽象类中包含了两个维度的接口1234567891011121314151617181920class Messager&#123;protected: MessagerImp * messageImp;public: Messager(MessagerImp *imp) : messageImp(imp) &#123;&#125; virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual ~Messager()&#123;&#125;&#125;;class MessagerImp&#123;public: virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual ~MessagerImp()&#123;&#125;&#125;; 12345678910111213141516171819202122232425262728293031class PCMessagerImp : public MessagerImp&#123;public: virtual void PlaySound()&#123; //********** &#125; virtual void DrawShape()&#123; //********** &#125; virtual void WriteText()&#123; //********** &#125; virtual void Connect()&#123; //********** &#125;&#125;;class MobileMessagerImp : public MessagerImp&#123;public: virtual void PlaySound()&#123; //========== &#125; virtual void DrawShape()&#123; //========== &#125; virtual void WriteText()&#123; //========== &#125; virtual void Connect()&#123; //========== &#125;&#125;;123456789101112131415161718192021222324252627282930313233343536373839class MessagerLite : public Messager &#123;public: MessagerLite(MessagerImp* mImp) : Messager(mImp) &#123;&#125; virtual void Login(string username, string password)&#123; messageImp-&gt;Connect(); //........ &#125; virtual void SendMessage(string message)&#123; messageImp-&gt;CWriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; messageImp-&gt;CDrawShape(); //........ &#125;&#125;;class MessagerPerfect : public Messager &#123;public: MessagerPerfect(MessagerImp* mImp) : Messager(mImp) &#123;&#125; virtual void Login(string username, string password)&#123; messageImp-&gt;CPlaySound(); //******** messageImp-&gt;CConnect(); //........ &#125; virtual void SendMessage(string message)&#123; messageImp-&gt;CPlaySound(); //******** messageImp-&gt;CWriteText(); //........ &#125; virtual void SendPicture(Image image)&#123; messageImp-&gt;CPlaySound(); //******** messageImp-&gt;CDrawShape(); //........ &#125;&#125;; 这里也可以通过抽象工厂自动完成Imp的实现123456void Process()&#123; //运行时装配 MessagerImp* mImp=new PCMessagerImp(); MessagerLite *mp =new MessagerLite(mImp); MessagerPerfect *ml =new MessagerPerfect(mImp);&#125; 总结 结构图","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"bridge","slug":"bridge","permalink":"https://note.sdking.fun/tags/bridge/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"sdking"},{"title":"设计模式-Decorator","slug":"设计模式-Decorator","date":"2021-06-08T13:13:15.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"blog/设计模式-Decorator/","link":"","permalink":"https://note.sdking.fun/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Decorator/","excerpt":"","text":"以下笔记摘录自李建忠老师的&lt;&lt;c++设计模式&gt;&gt;和书籍&lt;&lt;设计模式&gt;&gt; 动机希望给某个对象而不是整个类添加一些功能，或者说动态的给一个对象添加一些额外的职责 原始代码业务操作主体类扩展操作：加密更多可能的组合或扩展：加密、缓冲12345678class Stream&#123;public: virtual char Read(int number) = 0; virtual void Seek(int position) = 0; virtual void Write(char data) = 0; virtual ~Stream() &#123;&#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041class FileStream : public Stream&#123;public: virtual char Read(int number) &#123; //读文件流 &#125; virtual void Seek(int position)&#123; //定位文件流 &#125; virtual void Write(char data)&#123; //写文件流 &#125;&#125;;class NetworkStream : public Stream&#123;public: virtual char Read(int number) &#123; //读网络流 &#125; virtual void Seek(int position)&#123; //定位网络流 &#125; virtual void Write(char data)&#123; //写网络流 &#125;&#125;;class MemoryStream : public Stream&#123;public: virtual char Read(int number) &#123; //读内存流 &#125; virtual void Seek(int position)&#123; //定位内存流 &#125; virtual void Write(char data)&#123; //写内存流 &#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class CryptoFileStream : public FileStream&#123;public: virtual char Read(int number) &#123; //额外的加密操作... FileStream::Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... FileStream::Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... FileStream::Write(data); //额外的加密操作... &#125;&#125;;class CryptoNetworkStream : public NetworkStream&#123;public: virtual char Read(int number) &#123; //额外的加密操作... NetworkStream::Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... NetworkStream::Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... NetworkStream::Write(data); //额外的加密操作... &#125;&#125;;class CryptoMemoryStream : public MemoryStream&#123;public: virtual char Read(int number) &#123; //额外的加密操作... MemoryStream::Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... MemoryStream::Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... MemoryStream::Write(data); //额外的加密操作... &#125;&#125;;1234567891011121314151617181920class BufferdFileStream : public FileStream &#123; //...&#125;class BufferdNetworkStream : public NetworkStream &#123; //...&#125;class BufferdMemoryStream : public MemoryStream &#123; //...&#125;class CryptoBufferdFileStream : public BufferdFileStream &#123; //...&#125;class CryptoBufferdNetworkStream : public BufferdNetworkStream &#123; //...&#125;class CryptoBufferdMemoryStream : public BufferdMemoryStream &#123; //...&#125; 类的继承关系及扩展组合方式如下： 可以看到随着扩展种类增多，各种组合导致类的数量急剧增加 使用代码如下：12345//编译时装配FileStream * s1 = new FileStream();CryptoFileStream * s1 = new CryptoFileStream();BufferdFileStream * s2 = new BufferdFileStream();CryptoBufferdFileStream * s3 = new CryptoBufferdFileStream(); 重构： 第一个版本，重要的思路转换 扩展操作类由继承改为组合 CryptoFileStreamCryptoNetworkStreamCryptoMemoryStream1234567891011121314151617181920class CryptoFileStream&#123; FileStream * stream;public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;1234567891011121314151617181920class CryptoNetworkStream&#123; NetworkStream * stream;public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;1234567891011121314151617181920class CryptoMemoryStream&#123; MemoryStream * stream;public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 重构： 第二个版本，充分利用抽象类 扩展操作类子类对象指针改为基类指针，通过不同的初始化方式应不同的子类 CryptoFileStreamCryptoNetworkStreamCryptoMemoryStream1234567891011121314151617181920class CryptoFileStream&#123; Stream * stream; // = new FileStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;123456789101112131415161718192021class CryptoNetworkStream&#123; Stream * stream; // = new NetworkStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;;123456789101112131415161718192021class CryptoMemoryStream&#123; Stream * stream; // = new MemoryStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 重构： 第三个版本，合并简化 第二个重构版本中可以发现这三个类其实是完全一样，以合并为一个 1234567891011121314151617181920class CryptoStream&#123; Stream * stream; // = new FileStream(); or new NetworkStream(); or new MemoryStream();public: virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 为保留基类虚函数的规范，这个类还要继承Stream类，同时添加了构造函数 123456789101112131415161718192021class CryptoStream : public Stream&#123; Stream * stream; // = new FileStream(); or new NetworkStream(); or new MemoryStream();public: CryptoStream(Stream * stm) : stream(stm) &#123;&#125; virtual char Read(int number) &#123; //额外的加密操作... stream-&gt;Read(number); //额外的加密操作... &#125; virtual void Seek(int position)&#123; //额外的加密操作... stream-&gt;Seek(position); //额外的加密操作... &#125; virtual void Write(char data)&#123; //额外的加密操作... stream-&gt;Write(data); //额外的加密操作... &#125;&#125;; 会发现这个类既继承了基类，又含有基类指针成员，这也是decorator模式的一个重要标志 同理buffered扩展就重构为 123456789101112131415161718class BufferedStream : public Stream&#123; Stream * stream; // = new FileStream(); or new NetworkStream(); or new MemoryStream();public: BufferedStream(Stream * stm) : stream(stm) &#123;&#125; virtual char Read(int number) &#123; //额外的buffer操作... stream-&gt;Read(number); &#125; virtual void Seek(int position)&#123; //额外的buffer操作... stream-&gt;Seek(position); &#125; virtual void Write(char data)&#123; //额外的buffer操作... stream-&gt;Write(data); &#125;&#125;; 重构： 最后的版本，锦上添花 可以发现第三个版本中CryptoStream和BufferdStream中都有成员指针，那么就可以尝试将其往底层提取 一个直接的办法是放置在抽象类Stream中，但这样对三个主题类而言是多余的 所以可以再封装一个类DecoratorStream 12345678910111213141516171819class DecoratorStream : public Stream&#123; Stream * stream;public: DecoratorStream(Stream * stm) : stream(stm) &#123;&#125;&#125;;//扩展操作继承DecoratorStreamclass CryptoStream : public DecoratorStream&#123;public: CryptoStream(Stream * stm) : DecoratorStream(stm) &#123;&#125;&#125;；class BufferedStream : public DecoratorStream&#123;public: BufferedStream(Stream * stm) : DecoratorStream(stm) &#123;&#125;&#125;； 使用代码如下： 12345//运行时装配FileStream * s1 = new FileStream();CryptoStream * s2 = new CryptoStream(s1); //针对FileStream加密BufferdStream * s3 = new BufferdStream(s1); //针对FileStream缓冲BufferdStream * s4 = new BufferdStream(s2); //针对FileStream既缓冲又加密 总结 根源分析：某些情况下”过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质(扩展类中调用子类的Read，Seek，Write)，使得这种扩展方式缺乏灵活性。 模式定义：动态(组合)的给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类(继承)更为灵活(消除重复代码&amp;减少子类个数)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"decorator","slug":"decorator","permalink":"https://note.sdking.fun/tags/decorator/"}],"author":"sdking"},{"title":"manim-第一个程序","slug":"manim-第一个程序","date":"2021-06-05T13:09:00.000Z","updated":"2021-07-04T10:10:04.456Z","comments":true,"path":"blog/manim-第一个程序/","link":"","permalink":"https://note.sdking.fun/blog/manim-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","excerpt":"Manim is an engine for precise programatic animations","text":"Manim is an engine for precise programatic animations clone仓库1git clone https://github.com/3b1b/manim.git 运行demo12cd manimmanimgl example_scenes.py OpeningManimExample 编写一个 在manim目录下新建python文件demo.py，代码如下 1234567891011121314from manimlib.imports import *class SquareToCircle(Scene): def construct(self): circle = Circle() circle.set_fill(BLUE, opacity=0.5) circle.set_stroke(BLUE_A, width=4) square = Square() self.play(ShowCreation(square)) self.play(ReplacementTransform(square, circle)) self.wait() exit() 运行程序，执行manim demo.py SquareToCircle，就会展示如下动画 执行manim demo.py SquareToCircle -wm可以在videos目录下生成视屏文件 代码解析 定义场景类： 需要继承自场景类Scene override函数：construct 12class SquareToCircle(Scene): def construct(self): 场景元素添加并设置： 1234circle = Circle()circle.set_fill(BLUE, opacity=0.5)circle.set_stroke(BLUE_A, width=4)square = Square() 动画定义及播放： 12self.play(ShowCreation(square))self.play(ReplacementTransform(square, circle)) 以上。","categories":[{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/categories/manim/"}],"tags":[{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/tags/manim/"},{"name":"math","slug":"math","permalink":"https://note.sdking.fun/tags/math/"},{"name":"python","slug":"python","permalink":"https://note.sdking.fun/tags/python/"}]}],"categories":[{"name":"程序员的自我修养","slug":"程序员的自我修养","permalink":"https://note.sdking.fun/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/categories/manim/"}],"tags":[{"name":"prepressing","slug":"prepressing","permalink":"https://note.sdking.fun/tags/prepressing/"},{"name":"compile","slug":"compile","permalink":"https://note.sdking.fun/tags/compile/"},{"name":"assembly","slug":"assembly","permalink":"https://note.sdking.fun/tags/assembly/"},{"name":"link","slug":"link","permalink":"https://note.sdking.fun/tags/link/"},{"name":"设计模式","slug":"设计模式","permalink":"https://note.sdking.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"factorymethod","slug":"factorymethod","permalink":"https://note.sdking.fun/tags/factorymethod/"},{"name":"bridge","slug":"bridge","permalink":"https://note.sdking.fun/tags/bridge/"},{"name":"decorator","slug":"decorator","permalink":"https://note.sdking.fun/tags/decorator/"},{"name":"manim","slug":"manim","permalink":"https://note.sdking.fun/tags/manim/"},{"name":"math","slug":"math","permalink":"https://note.sdking.fun/tags/math/"},{"name":"python","slug":"python","permalink":"https://note.sdking.fun/tags/python/"}]}